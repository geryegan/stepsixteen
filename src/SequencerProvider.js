import React, { Component } from 'react';
import { SequencerContext } from './SequencerContext';
import WAAClock from 'waaclock';
window.AudioContext = window.AudioContext || window.webkitAudioContext;

//react16 context API -- Provider:
//this component returns a Provider component which is generated by the Context created by createContext()
class SequencerProvider extends Component {
  constructor(props) {
    super(props);
    this.state = {
      playing: false,
      activeStep: 0,
      trackLength: 16
    };
    // this.play = this.play.bind(this);
    this.togglePlay = this.togglePlay.bind(this);
    this.handleDropdownChange = this.handleDropdownChange.bind(this);
    this.playInterval = null;
    this.handleTick = this.handleTick.bind(this);
  }

  componentDidMount() {
    this.context = new AudioContext();
    this.clock = new WAAClock(this.context);
  }
  componentDidUpdate(prevProps, prevState) {
    if (prevState.playing !== this.state.playing) {
      this.context = new AudioContext();
    }
  }

  // play() {
  //   if (!document.hasFocus()) {
  //     this.setState({ playing: false });
  //     clearInterval(this.playInterval);
  //   }
  //   this.setState((state) => ({
  //     activeStep: state.activeStep < this.state.trackLength ? state.activeStep + 1 : 1
  //   }));
  // }

  handleTick({ deadline }) {
    setTimeout(() => {
      this.setState((state) => ({
        activeStep: state.activeStep < this.state.trackLength ? state.activeStep + 1 : 1
      }));
    }, deadline - this.context.currentTime);
  }

  togglePlay() {
    const { playing } = this.state;
    if (!playing) {
      // this.playInterval = setInterval(this.play, 125);
      this.setState((state) => ({
        playing: !state.playing,
        activeStep: -1
      }));
      this.clock.start();
      this.tickEvent = this.clock.callbackAtTime(this.handleTick.bind(this), this.context.currentTime).repeat(0.125);
      console.log(this.handleTick);
    } else {
      // clearInterval(this.playInterval);
      this.clock.stop();
      this.setState((state) => ({
        playing: !state.playing
      }));
    }
  }

  handleDropdownChange(e) {
    console.log(e.target);
    this.setState({ trackLength: e.target.value });
  }

  render() {
    return (
      // I didn't destructure the provider off of the Context when I created it, hence the <Context.Provider> syntax
      <SequencerContext.Provider
        value={{
          state: this.state,
          togglePlay: () => this.togglePlay(),
          handleDropdownChange: this.handleDropdownChange
        }}
      >
        {this.props.children}
      </SequencerContext.Provider>
    );
  }
}

export default SequencerProvider;
